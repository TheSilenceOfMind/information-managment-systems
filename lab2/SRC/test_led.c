#include "aduc812.h"
#include "led.h"
#include "max.h"

unsigned long __systime = 0;
int t = 20;	// период одного сигнала, необходим для изменения скважности сигнала

/*  соответствие номера диода и его маске 
1 - 1  (00000001)
2 - 2  (00000010)
3 - 4  (00000100)
4 - 8
5 - 16
6 - 32
7 - 64
8 - 128
*/

/*  массив с масками, соответсвующим диодам, которые должны светиться с определенной яркостью (номер эл-та - яркость в %):
0 - 0 
1 - 0
2 - 0
3 - 20 
4 - 40
5 - 60
6 - 80
7 - 100  

начальное состояние соответствует второй строке на картинке с анимацией  */
unsigned char[8] leds_brights = { 1, 2, 4, 8, 16, 32, 64, 128 }

///////////////////////////////////////////////////////////////////////////
// Инициализация Таймера 0 (1000Гц)
///////////////////////////////////////////////////////////////////////////
void InitSystimer0( void )
{
	TCON = 0x00; 	// Выключение таймера 0 (и таймера 1)
	TMOD = 0x01; 	// Выбор режима работы 16-разрядный таймер
	TH0 = 0xFC; 	// Инициализация таймера 0:
	TL0 = 0x67; 	// настройка на частоту работы 1000 Гц (чуть больше)
	TCON = 0x10; 	// Включение таймера 0
}
///////////////////////////////////////////////////////////////////////////
// Чтение милисекундного счетчика
///////////////////////////////////////////////////////////////////////////
unsigned long GetMsCounter( void )
{
	unsigned long res;
	ET0 = 0;
	res = __systime;
	ET0 = 1;
	return res;
}
///////////////////////////////////////////////////////////////////////////
// Возвращает прошедшее время (от момента замера)
///////////////////////////////////////////////////////////////////////////
unsigned long DTimeMs( unsigned long t2 )
{
	unsigned long t1 = ( unsigned long )GetMsCounter();
	return t1 - t2;
}
///////////////////////////////////////////////////////////////////////////
// Задержка в милисекундах
///////////////////////////////////////////////////////////////////////////
void DelayMs( unsigned long ms )
{
	unsigned long t1 = ( unsigned long )GetMsCounter();
	while ( 1 )
	{
		if ( DTimeMs( t1 ) > ms ) break;
	}
}

//////////////////////// T0_ISR //////////////////////////////
// Обработчик прерывания от таймера 0.
//////////////////////////////////////////////////////////////
void T0_ISR( void ) __interrupt ( 1 )
{
	// Время в милисекундах
	__systime++;
	TH0 = 0xFC; // Инициализация таймера 0:
	TL0 = 0x67; // настройка на частоту работы 1000 Гц (чуть больше)
}

//////////////////////// SetVector //////////////////////////
// Функция, устанавливающая вектор прерывания в пользовательской таблице
// прерываний.
// Вход: Vector - адрес обработчика прерывания,
// Address - вектор пользовательской таблицы прерываний.
// Выход: нет.
// Результат: нет.
//////////////////////////////////////////////////////////////

void SetVector(unsigned char __xdata * Address, void * Vector)
{
	unsigned char __xdata * TmpVector; // Временная переменная
	// Первым байтом по указанному адресу записывается
	// код команды передачи управления ljmp, равный 02h
	*Address = 0x02;
	// Далее записывается адрес перехода Vector
	TmpVector = (unsigned char __xdata *) (Address + 1);
	*TmpVector = (unsigned char) ((unsigned short)Vector >> 8);
	++TmpVector;
	*TmpVector = (unsigned char) Vector;
	// Таким образом, по адресу Address теперь
	// располагается инструкция ljmp Vector
}


//////////////////////// DisplayLeds //////////////////////////
// Функция, зажигающая линейку светодиодов с заданной яркостью 
// каждого светодиода
// Вход: ms - длительность зажигания,
// leds_brights - массив, задающий маски для диодов согласно их
// яркости.
// Выход: нет.
// Результат: нет.
//////////////////////////////////////////////////////////////

/*  соответствие номера диода в линейке диодов и его маске в общей линейке диодов
1 - 1  (00000001)
2 - 2  (00000010)
3 - 4  (00000100)
4 - 8
5 - 16
6 - 32
7 - 64
8 - 128

Чем больше порядковый номер в массиве, тем больше яркость того диода, который задается маской - элементом массива
(индекс в массиве) - (процент яркости)
0 - 0 
1 - 0
2 - 0
3 - 20 
4 - 40
5 - 60
6 - 80
7 - 100
*/

void DisplayLeds (unsigned long ms, unsigned char leds_brights[8])  {
	volatile unsigned long j;	
	volatile unsigned long rem;
	/* разбиваем период на 5 промежутков, чтобы подавать разные уровни сигнала в разные интервалы 
	   периода на различные диоды, то бишь изменяем скважности сигналов, подаваемых на диоды */
	int b1, b2, b3, b4;
	b1 = t/5; b2 = 2*b1; b3 = 3*b1; b4 = 4*b1;

	leds (0);	
    for (j = 0; j < ms; j++) {
    	rem = j % t;
    	if (rem < b1) {  
    		// самый первый промежуток периода => подадим высокий уровень сигнала на все светящиеся диоды
    		leds (leds_brights[3] | leds_brights[4] | leds_brights[5] | leds_brights[6] | leds_brights[7]);
    	} else if (rem < b2) {
    		// подадим 0 на менее яркий диод, остальные пускай продолжают получать высокий уровень сигнала
    		leds (leds_brights[4] | leds_brights[5] | leds_brights[6] | leds_brights[7]);
    	} else if (rem < b3) {
    		leds (leds_brights[5] | leds_brights[6] | leds_brights[7]);
    	} else if (rem < b4) {
    		leds (leds_brights[6] | leds_brights[7]);
    	} else {
    		// единственный диод со стопроцентной яркостью => получает высокий уровень сигнала весь период
    		leds (leds_brights[7]);
    	}
    }
}

void delay2 ( unsigned long ms )
{
    volatile unsigned long i, j;

    for( j = 0; j < ms; j++ )
    {
        for( i = 0; i < 50; i++ );
    }
}

void main( void )
{
	while(1) {
		DisplayLeds(5000);
		leds(0);
		delay2(500);
	}
	/*
	unsigned char light = 1;
	InitSystimer0();
	// Установка вектора в пользовательской таблице
	SetVector( 0x200B, (void *)T0_ISR );
	// Разрешение прерываний от таймера 0
	ET0 = 1; EA = 1;
	while( 1 )
	{
		leds( light );
		if( light == 0xFF ) light = 1;
		else light |= light << 1;
		DelayMs( 300 );
	}
	*/
}   