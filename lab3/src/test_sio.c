#include "aduc812.h"
#include "sio.h"
#include "led.h"

#define NEWLINE_R 	0x0D
#define NEWLINE_W	0x0A
#define DEFAULT_VAL	0xFF

/*
    symbols -   при чтении равна кол-ву считанных символов,
                при записи - нужна для записи десятков и перевода строки в SBUF

    results -   здесь накапливается считанное число в 10-ой СС
*/
unsigned char result, symbols;


/**----------------------------------------------------------------------------
                        reset()
-------------------------------------------------------------------------------
Вход:		нет
Выход:		нет
Описание:	Сбрасывает результат конвертации
----------------------------------------------------------------------------- */
void reset() {
		result = 0;
		symbols = 0;
}

/**----------------------------------------------------------------------------
                            SetVectir
-------------------------------------------------------------------------------
Вход:
		Vector – адрес обработчика прерывания,
		Address – вектор пользовательской таблицы прерываний.
Выход:		нет
Результат:	нет
Описание:	Функция, устанавливающая вектор прерывания в
			пользовательской таблие прерываний
-----------------------------------------------------------------------------*/
void SetVector(unsigned char __xdata * Address, void * Vector)
{
	unsigned char __xdata * TmpVector;
	// Первым байтом по указанному адресу записывается // код команды передачи управления ljmp, равный 02h
	*Address = 0x02;
	// Далее записывается адрес перехода Vector
	TmpVector = (unsigned char __xdata *) (Address + 1);
	*TmpVector = (unsigned char) ((unsigned short)Vector >> 8);
	++TmpVector;
	*TmpVector = (unsigned char) Vector;
	// Таким образом, по адресу Address теперь
	// располагается инструкция ljmp Vector
}

/**----------------------------------------------------------------------------
                        mistake()
-------------------------------------------------------------------------------
Вход:		нет
Выход:		нет
Описание:	Вывод в терминал сообщения об ошибке а также
			сигнализирование об этом путём зажигания всех диодов.
----------------------------------------------------------------------------- */
void mistake( void ) {
			EA = 0;
			ES = 0;
			type ( "Mistake has happend\n" );
			leds( DEFAULT_VAL );
			reset();
			EA = 1;
			ES = 1;
}

/**----------------------------------------------------------------------------
                            SIO_ISR
-------------------------------------------------------------------------------
Вход:		нет
Выход:		нет
Описание:	Обработчик прерывания от последовательного канала
-----------------------------------------------------------------------------*/
void SIO_ISR( void ) __interrupt ( 4 )
{
	unsigned char r_buf;
	//Блок прерывания по отправлению данных
	if( TI )
	{
		// Данный блок отправляет цифру - сотни
		if ( 100 < result )
		{
			SBUF = ( result / 100 ) + '0';
			result = result - ( result / 100 ) * 100;
		}
		// Данный блок отправляет цифру - десятки
		else if ( 10 < result )
		{
			SBUF = ( result / 10 ) + '0';
			result = result % 10;
			symbols = 2;
		}
		// Данный блок отправляет цифру - единицы
		else if ( 2 == symbols )
		{
			SBUF = result + '0';
			symbols = 1;
		}
		// Отправляем перенос строки
		else if ( 1 == symbols )
		{
			SBUF = NEWLINE_W;
			reset();
		}

		TI = 0;
	}

	//Блок прерывания по приёму данных
	if( RI )
	{
		r_buf = SBUF;
		leds( r_buf ); //Подсветка считанного символа для debug
		RI = 0;

		if ( '0' <= r_buf && r_buf <= '9' || 'A' <= r_buf && r_buf <= 'F')
		{
			unsigned char digit = (r_buf < 'A') ? (r_buf - '0') : (r_buf - 'A' + 10);
			symbols++;

			if ( symbols <= 2 ) // Если введено небольше 2 цифр
				result = (result << 4) + digit;
			else
				mistake();
		}
		else if ( r_buf == NEWLINE_R )
		{
			// Перенос строки после ввода цифр
			if ( symbols )
			{
				symbols = 2;
				TI = 1;
			}
			else
				mistake();
		}
		else // Введён некорректный символ
			mistake();
	}
}

void main( void )
{
	unsigned char c;
	SetVector((unsigned char __xdata *)0x2023, (void *)SIO_ISR);
	init_sio(S9600);
	reset();

	while( 1 )
	{
		//В положение DIP-переключателя 0xFF будем работать синхронно
		if (DEFAULT_VAL == readdip() )
		{
			//На момент синхронной работы отключим прерывания
			EA = 0;
			ES = 0;

			if( rsiostat() )
			{
				c = rsio();

				if ('a' <= c && c <= 'z')
				{
					char i;

					wsio(c);
					for (i = c - 1; i >= 'a'; i--)
						wsio(i - 32);
					wsio(NEWLINE_W);
				}
			}
		}
		else
		{
			EA=1;
			ES=1;
		}
	}
}
